"use strict";
/*
* Copyright (c) 2019, FusionAuth, All Rights Reserved
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
* either express or implied. See the License for the specific
* language governing permissions and limitations under the License.
*/
import DefaultRESTClientNativeBuilder from "@/lib/DeafaultRestClientNativeBuilder";

export default class FusionAuthClientNative {
    private apiKey: any;
    private host: any;
    private tenantId: any;
    private clientBuilder: DefaultRESTClientNativeBuilder;
    credentials: RequestCredentials;
    constructor(apiKey, host, tenantId?) {
        this.apiKey = apiKey;
        this.host = host;
        this.tenantId = tenantId;
        this.clientBuilder = new DefaultRESTClientNativeBuilder();
    }
    /**
     * Sets the tenant id, that will be included in the X-FusionAuth-TenantId header.
     *
     * @param {string | null} tenantId The value of the X-FusionAuth-TenantId header.
     * @returns {FusionAuthClient}
     */
    setTenantId(tenantId) {
        this.tenantId = tenantId;
        return this;
    }
    /**
     * Takes an action on a user. The user being actioned is called the "actionee" and the user taking the action is called the
     * "actioner". Both user ids are required. You pass the actionee's user id into the method and the actioner's is put into the
     * request object.
     *
     * @param {string} actioneeUserId The actionee's user id.
     * @param {ActionRequest} request The action request that includes all of the information about the action being taken including
     *    the id of the action, any options and the duration (if applicable).
     * @returns {Promise<ClientResponse<ActionResponse>>}
     */
    actionUser(actioneeUserId, request) {
        return this.start()
            .withUri('/api/user/action')
            .withUriSegment(actioneeUserId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Adds a user to an existing family. The family id must be specified.
     *
     * @param {string} familyId The id of the family.
     * @param {FamilyRequest} request The request object that contains all of the information used to determine which user to add to the family.
     * @returns {Promise<ClientResponse<FamilyResponse>>}
     */
    addUserToFamily(familyId, request) {
        return this.start()
            .withUri('/api/user/family')
            .withUriSegment(familyId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Cancels the user action.
     *
     * @param {string} actionId The action id of the action to cancel.
     * @param {ActionRequest} request The action request that contains the information about the cancellation.
     * @returns {Promise<ClientResponse<ActionResponse>>}
     */
    cancelAction(actionId, request) {
        return this.start()
            .withUri('/api/user/action')
            .withUriSegment(actionId)
            .withJSONBody(request)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Changes a user's password using the change password Id. This usually occurs after an email has been sent to the user
     * and they clicked on a link to reset their password.
     *
     * @param {string} changePasswordId The change password Id used to find the user. This value is generated by FusionAuth once the change password workflow has been initiated.
     * @param {ChangePasswordRequest} request The change password request that contains all of the information used to change the password.
     * @returns {Promise<ClientResponse<ChangePasswordResponse>>}
     */
    changePassword(changePasswordId, request) {
        return this.start()
            .withUri('/api/user/change-password')
            .withUriSegment(changePasswordId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Changes a user's password using their identity (login id and password). Using a loginId instead of the changePasswordId
     * bypasses the email verification and allows a password to be changed directly without first calling the #forgotPassword
     * method.
     *
     * @param {ChangePasswordRequest} request The change password request that contains all of the information used to change the password.
     * @returns {Promise<ClientResponse<void>>}
     */
    changePasswordByIdentity(request) {
        return this.start()
            .withUri('/api/user/change-password')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Adds a comment to the user's account.
     *
     * @param {UserCommentRequest} request The request object that contains all of the information used to create the user comment.
     * @returns {Promise<ClientResponse<void>>}
     */
    commentOnUser(request) {
        return this.start()
            .withUri('/api/user/comment')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates an application. You can optionally specify an Id for the application, if not provided one will be generated.
     *
     * @param {string} applicationId (Optional) The Id to use for the application. If not provided a secure random UUID will be generated.
     * @param {ApplicationRequest} request The request object that contains all of the information used to create the application.
     * @returns {Promise<ClientResponse<ApplicationResponse>>}
     */
    createApplication(applicationId, request) {
        return this.start()
            .withUri('/api/application')
            .withUriSegment(applicationId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates a new role for an application. You must specify the id of the application you are creating the role for.
     * You can optionally specify an Id for the role inside the ApplicationRole object itself, if not provided one will be generated.
     *
     * @param {string} applicationId The Id of the application to create the role on.
     * @param {string} roleId (Optional) The Id of the role. If not provided a secure random UUID will be generated.
     * @param {ApplicationRequest} request The request object that contains all of the information used to create the application role.
     * @returns {Promise<ClientResponse<ApplicationResponse>>}
     */
    createApplicationRole(applicationId, roleId, request) {
        return this.start()
            .withUri('/api/application')
            .withUriSegment(applicationId)
            .withUriSegment("role")
            .withUriSegment(roleId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates an audit log with the message and user name (usually an email). Audit logs should be written anytime you
     * make changes to the FusionAuth database. When using the FusionAuth App web interface, any changes are automatically
     * written to the audit log. However, if you are accessing the API, you must write the audit logs yourself.
     *
     * @param {AuditLogRequest} request The request object that contains all of the information used to create the audit log entry.
     * @returns {Promise<ClientResponse<AuditLogResponse>>}
     */
    createAuditLog(request) {
        return this.start()
            .withUri('/api/system/audit-log')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates a user consent type. You can optionally specify an Id for the consent type, if not provided one will be generated.
     *
     * @param {string} consentId (Optional) The Id for the consent. If not provided a secure random UUID will be generated.
     * @param {ConsentRequest} request The request object that contains all of the information used to create the consent.
     * @returns {Promise<ClientResponse<ConsentResponse>>}
     */
    createConsent(consentId, request) {
        return this.start()
            .withUri('/api/consent')
            .withUriSegment(consentId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates an email template. You can optionally specify an Id for the template, if not provided one will be generated.
     *
     * @param {string} emailTemplateId (Optional) The Id for the template. If not provided a secure random UUID will be generated.
     * @param {EmailTemplateRequest} request The request object that contains all of the information used to create the email template.
     * @returns {Promise<ClientResponse<EmailTemplateResponse>>}
     */
    createEmailTemplate(emailTemplateId, request) {
        return this.start()
            .withUri('/api/email/template')
            .withUriSegment(emailTemplateId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates a family with the user id in the request as the owner and sole member of the family. You can optionally specify an id for the
     * family, if not provided one will be generated.
     *
     * @param {string} familyId (Optional) The id for the family. If not provided a secure random UUID will be generated.
     * @param {FamilyRequest} request The request object that contains all of the information used to create the family.
     * @returns {Promise<ClientResponse<FamilyResponse>>}
     */
    createFamily(familyId, request) {
        return this.start()
            .withUri('/api/user/family')
            .withUriSegment(familyId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates a group. You can optionally specify an Id for the group, if not provided one will be generated.
     *
     * @param {string} groupId (Optional) The Id for the group. If not provided a secure random UUID will be generated.
     * @param {GroupRequest} request The request object that contains all of the information used to create the group.
     * @returns {Promise<ClientResponse<GroupResponse>>}
     */
    createGroup(groupId, request) {
        return this.start()
            .withUri('/api/group')
            .withUriSegment(groupId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates a member in a group.
     *
     * @param {MemberRequest} request The request object that contains all of the information used to create the group member(s).
     * @returns {Promise<ClientResponse<MemberResponse>>}
     */
    createGroupMembers(request) {
        return this.start()
            .withUri('/api/group/member')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates an identity provider. You can optionally specify an Id for the identity provider, if not provided one will be generated.
     *
     * @param {string} identityProviderId (Optional) The Id of the identity provider. If not provided a secure random UUID will be generated.
     * @param {IdentityProviderRequest} request The request object that contains all of the information used to create the identity provider.
     * @returns {Promise<ClientResponse<IdentityProviderResponse>>}
     */
    createIdentityProvider(identityProviderId, request) {
        return this.start()
            .withUri('/api/identity-provider')
            .withUriSegment(identityProviderId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates a Lambda. You can optionally specify an Id for the lambda, if not provided one will be generated.
     *
     * @param {string} lambdaId (Optional) The Id for the lambda. If not provided a secure random UUID will be generated.
     * @param {LambdaRequest} request The request object that contains all of the information used to create the lambda.
     * @returns {Promise<ClientResponse<LambdaResponse>>}
     */
    createLambda(lambdaId, request) {
        return this.start()
            .withUri('/api/lambda')
            .withUriSegment(lambdaId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates a tenant. You can optionally specify an Id for the tenant, if not provided one will be generated.
     *
     * @param {string} tenantId (Optional) The Id for the tenant. If not provided a secure random UUID will be generated.
     * @param {TenantRequest} request The request object that contains all of the information used to create the tenant.
     * @returns {Promise<ClientResponse<TenantResponse>>}
     */
    createTenant(tenantId, request) {
        return this.start()
            .withUri('/api/tenant')
            .withUriSegment(tenantId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates a Theme. You can optionally specify an Id for the theme, if not provided one will be generated.
     *
     * @param {string} themeId (Optional) The Id for the theme. If not provided a secure random UUID will be generated.
     * @param {ThemeRequest} request The request object that contains all of the information used to create the theme.
     * @returns {Promise<ClientResponse<ThemeResponse>>}
     */
    createTheme(themeId, request) {
        return this.start()
            .withUri('/api/theme')
            .withUriSegment(themeId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates a user. You can optionally specify an Id for the user, if not provided one will be generated.
     *
     * @param {string} userId (Optional) The Id for the user. If not provided a secure random UUID will be generated.
     * @param {UserRequest} request The request object that contains all of the information used to create the user.
     * @returns {Promise<ClientResponse<UserResponse>>}
     */
    createUser(userId, request) {
        return this.start()
            .withUri('/api/user')
            .withUriSegment(userId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates a user action. This action cannot be taken on a user until this call successfully returns. Anytime after
     * that the user action can be applied to any user.
     *
     * @param {string} userActionId (Optional) The Id for the user action. If not provided a secure random UUID will be generated.
     * @param {UserActionRequest} request The request object that contains all of the information used to create the user action.
     * @returns {Promise<ClientResponse<UserActionResponse>>}
     */
    createUserAction(userActionId, request) {
        return this.start()
            .withUri('/api/user-action')
            .withUriSegment(userActionId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates a user reason. This user action reason cannot be used when actioning a user until this call completes
     * successfully. Anytime after that the user action reason can be used.
     *
     * @param {string} userActionReasonId (Optional) The Id for the user action reason. If not provided a secure random UUID will be generated.
     * @param {UserActionReasonRequest} request The request object that contains all of the information used to create the user action reason.
     * @returns {Promise<ClientResponse<UserActionReasonResponse>>}
     */
    createUserActionReason(userActionReasonId, request) {
        return this.start()
            .withUri('/api/user-action-reason')
            .withUriSegment(userActionReasonId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates a single User consent.
     *
     * @param {string} userConsentId (Optional) The Id for the User consent. If not provided a secure random UUID will be generated.
     * @param {UserConsentRequest} request The request that contains the user consent information.
     * @returns {Promise<ClientResponse<UserConsentResponse>>}
     */
    createUserConsent(userConsentId, request) {
        return this.start()
            .withUri('/api/user/consent')
            .withUriSegment(userConsentId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Creates a webhook. You can optionally specify an Id for the webhook, if not provided one will be generated.
     *
     * @param {string} webhookId (Optional) The Id for the webhook. If not provided a secure random UUID will be generated.
     * @param {WebhookRequest} request The request object that contains all of the information used to create the webhook.
     * @returns {Promise<ClientResponse<WebhookResponse>>}
     */
    createWebhook(webhookId, request) {
        return this.start()
            .withUri('/api/webhook')
            .withUriSegment(webhookId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Deactivates the application with the given Id.
     *
     * @param {string} applicationId The Id of the application to deactivate.
     * @returns {Promise<ClientResponse<void>>}
     */
    deactivateApplication(applicationId) {
        return this.start()
            .withUri('/api/application')
            .withUriSegment(applicationId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deactivates the user with the given Id.
     *
     * @param {string} userId The Id of the user to deactivate.
     * @returns {Promise<ClientResponse<void>>}
     */
    deactivateUser(userId) {
        return this.start()
            .withUri('/api/user')
            .withUriSegment(userId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deactivates the user action with the given Id.
     *
     * @param {string} userActionId The Id of the user action to deactivate.
     * @returns {Promise<ClientResponse<void>>}
     */
    deactivateUserAction(userActionId) {
        return this.start()
            .withUri('/api/user-action')
            .withUriSegment(userActionId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deactivates the users with the given ids.
     *
     * @param {Array<string>} userIds The ids of the users to deactivate.
     * @returns {Promise<ClientResponse<void>>}
     */
    deactivateUsers(userIds) {
        return this.start()
            .withUri('/api/user/bulk')
            .withParameter('userId', userIds)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Hard deletes an application. This is a dangerous operation and should not be used in most circumstances. This will
     * delete the application, any registrations for that application, metrics and reports for the application, all the
     * roles for the application, and any other data associated with the application. This operation could take a very
     * long time, depending on the amount of data in your database.
     *
     * @param {string} applicationId The Id of the application to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteApplication(applicationId) {
        return this.start()
            .withUri('/api/application')
            .withUriSegment(applicationId)
            .withParameter('hardDelete', true)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Hard deletes an application role. This is a dangerous operation and should not be used in most circumstances. This
     * permanently removes the given role from all users that had it.
     *
     * @param {string} applicationId The Id of the application to deactivate.
     * @param {string} roleId The Id of the role to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteApplicationRole(applicationId, roleId) {
        return this.start()
            .withUri('/api/application')
            .withUriSegment(applicationId)
            .withUriSegment("role")
            .withUriSegment(roleId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the consent for the given Id.
     *
     * @param {string} consentId The Id of the consent to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteConsent(consentId) {
        return this.start()
            .withUri('/api/consent')
            .withUriSegment(consentId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the email template for the given Id.
     *
     * @param {string} emailTemplateId The Id of the email template to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteEmailTemplate(emailTemplateId) {
        return this.start()
            .withUri('/api/email/template')
            .withUriSegment(emailTemplateId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the group for the given Id.
     *
     * @param {string} groupId The Id of the group to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteGroup(groupId) {
        return this.start()
            .withUri('/api/group')
            .withUriSegment(groupId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Removes users as members of a group.
     *
     * @param {MemberDeleteRequest} request The member request that contains all of the information used to remove members to the group.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteGroupMembers(request) {
        return this.start()
            .withUri('/api/group/member')
            .withJSONBody(request)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the identity provider for the given Id.
     *
     * @param {string} identityProviderId The Id of the identity provider to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteIdentityProvider(identityProviderId) {
        return this.start()
            .withUri('/api/identity-provider')
            .withUriSegment(identityProviderId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the key for the given Id.
     *
     * @param {string} keyOd The Id of the key to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteKey(keyOd) {
        return this.start()
            .withUri('/api/key')
            .withUriSegment(keyOd)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the lambda for the given Id.
     *
     * @param {string} lambdaId The Id of the lambda to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteLambda(lambdaId) {
        return this.start()
            .withUri('/api/lambda')
            .withUriSegment(lambdaId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the user registration for the given user and application.
     *
     * @param {string} userId The Id of the user whose registration is being deleted.
     * @param {string} applicationId The Id of the application to remove the registration for.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteRegistration(userId, applicationId) {
        return this.start()
            .withUri('/api/user/registration')
            .withUriSegment(userId)
            .withUriSegment(applicationId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the tenant for the given Id.
     *
     * @param {string} tenantId The Id of the tenant to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteTenant(tenantId) {
        return this.start()
            .withUri('/api/tenant')
            .withUriSegment(tenantId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the theme for the given Id.
     *
     * @param {string} themeId The Id of the theme to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteTheme(themeId) {
        return this.start()
            .withUri('/api/theme')
            .withUriSegment(themeId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the user for the given Id. This permanently deletes all information, metrics, reports and data associated
     * with the user.
     *
     * @param {string} userId The Id of the user to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteUser(userId) {
        return this.start()
            .withUri('/api/user')
            .withUriSegment(userId)
            .withParameter('hardDelete', true)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the user action for the given Id. This permanently deletes the user action and also any history and logs of
     * the action being applied to any users.
     *
     * @param {string} userActionId The Id of the user action to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteUserAction(userActionId) {
        return this.start()
            .withUri('/api/user-action')
            .withUriSegment(userActionId)
            .withParameter('hardDelete', true)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the user action reason for the given Id.
     *
     * @param {string} userActionReasonId The Id of the user action reason to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteUserActionReason(userActionReasonId) {
        return this.start()
            .withUri('/api/user-action-reason')
            .withUriSegment(userActionReasonId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the users with the given ids.
     *
     * @param {UserDeleteRequest} request The ids of the users to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteUsers(request) {
        return this.start()
            .withUri('/api/user/bulk')
            .withJSONBody(request)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Deletes the webhook for the given Id.
     *
     * @param {string} webhookId The Id of the webhook to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    deleteWebhook(webhookId) {
        return this.start()
            .withUri('/api/webhook')
            .withUriSegment(webhookId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Disable Two Factor authentication for a user.
     *
     * @param {string} userId The Id of the User for which you're disabling Two Factor authentication.
     * @param {string} code The Two Factor code used verify the the caller knows the Two Factor secret.
     * @returns {Promise<ClientResponse<void>>}
     */
    disableTwoFactor(userId, code) {
        return this.start()
            .withUri('/api/user/two-factor')
            .withParameter('userId', userId)
            .withParameter('code', code)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Enable Two Factor authentication for a user.
     *
     * @param {string} userId The Id of the user to enable Two Factor authentication.
     * @param {TwoFactorRequest} request The two factor enable request information.
     * @returns {Promise<ClientResponse<void>>}
     */
    enableTwoFactor(userId, request) {
        return this.start()
            .withUri('/api/user/two-factor')
            .withUriSegment(userId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Exchange a refresh token for a new JWT.
     *
     * @param {RefreshRequest} request The refresh request.
     * @returns {Promise<ClientResponse<RefreshResponse>>}
     */
    exchangeRefreshTokenForJWT(request) {
        return this.start()
            .withUri('/api/jwt/refresh')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Begins the forgot password sequence, which kicks off an email to the user so that they can reset their password.
     *
     * @param {ForgotPasswordRequest} request The request that contains the information about the user so that they can be emailed.
     * @returns {Promise<ClientResponse<ForgotPasswordResponse>>}
     */
    forgotPassword(request) {
        return this.start()
            .withUri('/api/user/forgot-password')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Generate a new Email Verification Id to be used with the Verify Email API. This API will not attempt to send an
     * email to the User. This API may be used to collect the verificationId for use with a third party system.
     *
     * @param {string} email The email address of the user that needs a new verification email.
     * @returns {Promise<ClientResponse<VerifyEmailResponse>>}
     */
    generateEmailVerificationId(email) {
        return this.start()
            .withUri('/api/user/verify-email')
            .withParameter('email', email)
            .withParameter('sendVerifyEmail', false)
            .withMethod("PUT")
            .go();
    }
    /**
     * Generate a new RSA or EC key pair or an HMAC secret.
     *
     * @param {string} keyId (Optional) The Id for the key. If not provided a secure random UUID will be generated.
     * @param {KeyRequest} request The request object that contains all of the information used to create the key.
     * @returns {Promise<ClientResponse<KeyResponse>>}
     */
    generateKey(keyId, request) {
        return this.start()
            .withUri('/api/key/generate')
            .withUriSegment(keyId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Generate a new Application Registration Verification Id to be used with the Verify Registration API. This API will not attempt to send an
     * email to the User. This API may be used to collect the verificationId for use with a third party system.
     *
     * @param {string} email The email address of the user that needs a new verification email.
     * @param {string} applicationId The Id of the application to be verified.
     * @returns {Promise<ClientResponse<VerifyRegistrationResponse>>}
     */
    generateRegistrationVerificationId(email, applicationId) {
        return this.start()
            .withUri('/api/user/verify-registration')
            .withParameter('email', email)
            .withParameter('sendVerifyPasswordEmail', false)
            .withParameter('applicationId', applicationId)
            .withMethod("PUT")
            .go();
    }
    /**
     * Generate a Two Factor secret that can be used to enable Two Factor authentication for a User. The response will contain
     * both the secret and a Base32 encoded form of the secret which can be shown to a User when using a 2 Step Authentication
     * application such as Google Authenticator.
     *
     * @returns {Promise<ClientResponse<SecretResponse>>}
     */
    generateTwoFactorSecret() {
        return this.start()
            .withUri('/api/two-factor/secret')
            .withMethod("GET")
            .go();
    }
    /**
     * Generate a Two Factor secret that can be used to enable Two Factor authentication for a User. The response will contain
     * both the secret and a Base32 encoded form of the secret which can be shown to a User when using a 2 Step Authentication
     * application such as Google Authenticator.
     *
     * @param {string} encodedJWT The encoded JWT (access token).
     * @returns {Promise<ClientResponse<SecretResponse>>}
     */
    generateTwoFactorSecretUsingJWT(encodedJWT) {
        return this.start()
            .withUri('/api/two-factor/secret')
            .withAuthorization('JWT ' + encodedJWT)
            .withMethod("GET")
            .go();
    }
    /**
     * Handles login via third-parties including Social login, external OAuth and OpenID Connect, and other
     * login systems.
     *
     * @param {IdentityProviderLoginRequest} request The third-party login request that contains information from the third-party login
     *    providers that FusionAuth uses to reconcile the user's account.
     * @returns {Promise<ClientResponse<LoginResponse>>}
     */
    identityProviderLogin(request) {
        return this.start()
            .withUri('/api/identity-provider/login')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Import an existing RSA or EC key pair or an HMAC secret.
     *
     * @param {string} keyId (Optional) The Id for the key. If not provided a secure random UUID will be generated.
     * @param {KeyRequest} request The request object that contains all of the information used to create the key.
     * @returns {Promise<ClientResponse<KeyResponse>>}
     */
    importKey(keyId, request) {
        return this.start()
            .withUri('/api/key/import')
            .withUriSegment(keyId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Bulk imports multiple users. This does some validation, but then tries to run batch inserts of users. This reduces
     * latency when inserting lots of users. Therefore, the error response might contain some information about failures,
     * but it will likely be pretty generic.
     *
     * @param {ImportRequest} request The request that contains all of the information about all of the users to import.
     * @returns {Promise<ClientResponse<void>>}
     */
    importUsers(request) {
        return this.start()
            .withUri('/api/user/import')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Issue a new access token (JWT) for the requested Application after ensuring the provided JWT is valid. A valid
     * access token is properly signed and not expired.
     * <p>
     * This API may be used in an SSO configuration to issue new tokens for another application after the user has
     * obtained a valid token from authentication.
     *
     * @param {string} applicationId The Application Id for which you are requesting a new access token be issued.
     * @param {string} encodedJWT The encoded JWT (access token).
     * @returns {Promise<ClientResponse<IssueResponse>>}
     */
    issueJWT(applicationId, encodedJWT) {
        return this.start()
            .withUri('/api/jwt/issue')
            .withAuthorization('JWT ' + encodedJWT)
            .withParameter('applicationId', applicationId)
            .withMethod("GET")
            .go();
    }
    /**
     * Authenticates a user to FusionAuth.
     *
     * This API optionally requires an API key. See <code>Application.loginConfiguration.requireAuthentication</code>.
     *
     * @param {LoginRequest} request The login request that contains the user credentials used to log them in.
     * @returns {Promise<ClientResponse<LoginResponse>>}
     */
    login(request) {

        return this.start()
            .withUri('/api/login')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Sends a ping to FusionAuth indicating that the user was automatically logged into an application. When using
     * FusionAuth's SSO or your own, you should call this if the user is already logged in centrally, but accesses an
     * application where they no longer have a session. This helps correctly track login counts, times and helps with
     * reporting.
     *
     * @param {string} userId The Id of the user that was logged in.
     * @param {string} applicationId The Id of the application that they logged into.
     * @param {string} callerIPAddress (Optional) The IP address of the end-user that is logging in. If a null value is provided
     *    the IP address will be that of the client or last proxy that sent the request.
     * @returns {Promise<ClientResponse<void>>}
     */
    loginPing(userId, applicationId, callerIPAddress) {
        return this.start()
            .withUri('/api/login')
            .withUriSegment(userId)
            .withUriSegment(applicationId)
            .withParameter('ipAddress', callerIPAddress)
            .withMethod("PUT")
            .go();
    }
    /**
     * The Logout API is intended to be used to remove the refresh token and access token cookies if they exist on the
     * client and revoke the refresh token stored. This API does nothing if the request does not contain an access
     * token or refresh token cookies.
     *
     * @param {boolean} global When this value is set to true all of the refresh tokens issued to the owner of the
     *    provided token will be revoked.
     * @param {string} refreshToken (Optional) The refresh_token as a request parameter instead of coming in via a cookie.
     *    If provided this takes precedence over the cookie.
     * @returns {Promise<ClientResponse<void>>}
     */
    logout(global, refreshToken) {
        return this.start()
            .withHeader('Content-Type', 'text/plain')
            .withUri('/api/logout')
            .withParameter('global', global)
            .withParameter('refreshToken', refreshToken)
            .withMethod("POST")
            .go();
    }
    /**
     * Retrieves the identity provider for the given domain. A 200 response code indicates the domain is managed
     * by a registered identity provider. A 404 indicates the domain is not managed.
     *
     * @param {string} domain The domain or email address to lookup.
     * @returns {Promise<ClientResponse<LookupResponse>>}
     */
    lookupIdentityProvider(domain) {
        return this.start()
            .withUri('/api/identity-provider/lookup')
            .withParameter('domain', domain)
            .withMethod("GET")
            .go();
    }
    /**
     * Modifies a temporal user action by changing the expiration of the action and optionally adding a comment to the
     * action.
     *
     * @param {string} actionId The Id of the action to modify. This is technically the user action log id.
     * @param {ActionRequest} request The request that contains all of the information about the modification.
     * @returns {Promise<ClientResponse<ActionResponse>>}
     */
    modifyAction(actionId, request) {
        return this.start()
            .withUri('/api/user/action')
            .withUriSegment(actionId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Complete a login request using a passwordless code
     *
     * @param {PasswordlessLoginRequest} request The passwordless login request that contains all of the information used to complete login.
     * @returns {Promise<ClientResponse<LoginResponse>>}
     */
    passwordlessLogin(request) {
        return this.start()
            .withUri('/api/passwordless/login')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Reactivates the application with the given Id.
     *
     * @param {string} applicationId The Id of the application to reactivate.
     * @returns {Promise<ClientResponse<ApplicationResponse>>}
     */
    reactivateApplication(applicationId) {
        return this.start()
            .withUri('/api/application')
            .withUriSegment(applicationId)
            .withParameter('reactivate', true)
            .withMethod("PUT")
            .go();
    }
    /**
     * Reactivates the user with the given Id.
     *
     * @param {string} userId The Id of the user to reactivate.
     * @returns {Promise<ClientResponse<UserResponse>>}
     */
    reactivateUser(userId) {
        return this.start()
            .withUri('/api/user')
            .withUriSegment(userId)
            .withParameter('reactivate', true)
            .withMethod("PUT")
            .go();
    }
    /**
     * Reactivates the user action with the given Id.
     *
     * @param {string} userActionId The Id of the user action to reactivate.
     * @returns {Promise<ClientResponse<UserActionResponse>>}
     */
    reactivateUserAction(userActionId) {
        return this.start()
            .withUri('/api/user-action')
            .withUriSegment(userActionId)
            .withParameter('reactivate', true)
            .withMethod("PUT")
            .go();
    }
    /**
     * Reconcile a User to FusionAuth using JWT issued from another Identity Provider.
     *
     * @param {IdentityProviderLoginRequest} request The reconcile request that contains the data to reconcile the User.
     * @returns {Promise<ClientResponse<LoginResponse>>}
     */
    reconcileJWT(request) {
        return this.start()
            .withUri('/api/jwt/reconcile')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Request a refresh of the User search index. This API is not generally necessary and the search index will become consistent in a
     * reasonable amount of time. There may be scenarios where you may wish to manually request an index refresh. One example may be
     * if you are using the Search API or Delete Tenant API immediately following a User Create etc, you may wish to request a refresh to
     *  ensure the index immediately current before making a query request to the search index.
     *
     * @returns {Promise<ClientResponse<void>>}
     */
    refreshUserSearchIndex() {
        return this.start()
            .withUri('/api/user/search')
            .withMethod("PUT")
            .go();
    }
    /**
     * Registers a user for an application. If you provide the User and the UserRegistration object on this request, it
     * will create the user as well as register them for the application. This is called a Full Registration. However, if
     * you only provide the UserRegistration object, then the user must already exist and they will be registered for the
     * application. The user id can also be provided and it will either be used to look up an existing user or it will be
     * used for the newly created User.
     *
     * @param {string} userId (Optional) The Id of the user being registered for the application and optionally created.
     * @param {RegistrationRequest} request The request that optionally contains the User and must contain the UserRegistration.
     * @returns {Promise<ClientResponse<RegistrationResponse>>}
     */
    register(userId, request) {
        return this.start()
            .withUri('/api/user/registration')
            .withUriSegment(userId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Removes a user from the family with the given id.
     *
     * @param {string} familyId The id of the family to remove the user from.
     * @param {string} userId The id of the user to remove from the family.
     * @returns {Promise<ClientResponse<void>>}
     */
    removeUserFromFamily(familyId, userId) {
        return this.start()
            .withUri('/api/user/family')
            .withUriSegment(familyId)
            .withUriSegment(userId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Re-sends the verification email to the user.
     *
     * @param {string} email The email address of the user that needs a new verification email.
     * @returns {Promise<ClientResponse<VerifyEmailResponse>>}
     */
    resendEmailVerification(email) {
        return this.start()
            .withUri('/api/user/verify-email')
            .withParameter('email', email)
            .withMethod("PUT")
            .go();
    }
    /**
     * Re-sends the application registration verification email to the user.
     *
     * @param {string} email The email address of the user that needs a new verification email.
     * @param {string} applicationId The Id of the application to be verified.
     * @returns {Promise<ClientResponse<VerifyRegistrationResponse>>}
     */
    resendRegistrationVerification(email, applicationId) {
        return this.start()
            .withUri('/api/user/verify-registration')
            .withParameter('email', email)
            .withParameter('applicationId', applicationId)
            .withMethod("PUT")
            .go();
    }
    /**
     * Retrieves a single action log (the log of a user action that was taken on a user previously) for the given Id.
     *
     * @param {string} actionId The Id of the action to retrieve.
     * @returns {Promise<ClientResponse<ActionResponse>>}
     */
    retrieveAction(actionId) {
        return this.start()
            .withUri('/api/user/action')
            .withUriSegment(actionId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the actions for the user with the given Id. This will return all time based actions that are active,
     * and inactive as well as non-time based actions.
     *
     * @param {string} userId The Id of the user to fetch the actions for.
     * @returns {Promise<ClientResponse<ActionResponse>>}
     */
    retrieveActions(userId) {
        return this.start()
            .withUri('/api/user/action')
            .withParameter('userId', userId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the actions for the user with the given Id that are currently preventing the User from logging in.
     *
     * @param {string} userId The Id of the user to fetch the actions for.
     * @returns {Promise<ClientResponse<ActionResponse>>}
     */
    retrieveActionsPreventingLogin(userId) {
        return this.start()
            .withUri('/api/user/action')
            .withParameter('userId', userId)
            .withParameter('preventingLogin', true)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the actions for the user with the given Id that are currently active.
     * An active action means one that is time based and has not been canceled, and has not ended.
     *
     * @param {string} userId The Id of the user to fetch the actions for.
     * @returns {Promise<ClientResponse<ActionResponse>>}
     */
    retrieveActiveActions(userId) {
        return this.start()
            .withUri('/api/user/action')
            .withParameter('userId', userId)
            .withParameter('active', true)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the application for the given id or all of the applications if the id is null.
     *
     * @param {string} applicationId (Optional) The application id.
     * @returns {Promise<ClientResponse<ApplicationResponse>>}
     */
    retrieveApplication(applicationId) {
        return this.start()
            .withUri('/api/application')
            .withUriSegment(applicationId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the applications.
     *
     * @returns {Promise<ClientResponse<ApplicationResponse>>}
     */
    retrieveApplications() {
        return this.start()
            .withUri('/api/application')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves a single audit log for the given Id.
     *
     * @param {number} auditLogId The Id of the audit log to retrieve.
     * @returns {Promise<ClientResponse<AuditLogResponse>>}
     */
    retrieveAuditLog(auditLogId) {
        return this.start()
            .withUri('/api/system/audit-log')
            .withUriSegment(auditLogId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the Consent for the given Id.
     *
     * @param {string} consentId The Id of the consent.
     * @returns {Promise<ClientResponse<ConsentResponse>>}
     */
    retrieveConsent(consentId) {
        return this.start()
            .withUri('/api/consent')
            .withUriSegment(consentId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the consent.
     *
     * @returns {Promise<ClientResponse<ConsentResponse>>}
     */
    retrieveConsents() {
        return this.start()
            .withUri('/api/consent')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the daily active user report between the two instants. If you specify an application id, it will only
     * return the daily active counts for that application.
     *
     * @param {string} applicationId (Optional) The application id.
     * @param {number} start The start instant as UTC milliseconds since Epoch.
     * @param {number} end The end instant as UTC milliseconds since Epoch.
     * @returns {Promise<ClientResponse<DailyActiveUserReportResponse>>}
     */
    retrieveDailyActiveReport(applicationId, start, end) {
        return this.start()
            .withUri('/api/report/daily-active-user')
            .withParameter('applicationId', applicationId)
            .withParameter('start', start)
            .withParameter('end', end)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the email template for the given Id. If you don't specify the id, this will return all of the email templates.
     *
     * @param {string} emailTemplateId (Optional) The Id of the email template.
     * @returns {Promise<ClientResponse<EmailTemplateResponse>>}
     */
    retrieveEmailTemplate(emailTemplateId) {
        return this.start()
            .withUri('/api/email/template')
            .withUriSegment(emailTemplateId)
            .withMethod("GET")
            .go();
    }
    /**
     * Creates a preview of the email template provided in the request. This allows you to preview an email template that
     * hasn't been saved to the database yet. The entire email template does not need to be provided on the request. This
     * will create the preview based on whatever is given.
     *
     * @param {PreviewRequest} request The request that contains the email template and optionally a locale to render it in.
     * @returns {Promise<ClientResponse<PreviewResponse>>}
     */
    retrieveEmailTemplatePreview(request) {
        return this.start()
            .withUri('/api/email/template/preview')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Retrieves all of the email templates.
     *
     * @returns {Promise<ClientResponse<EmailTemplateResponse>>}
     */
    retrieveEmailTemplates() {
        return this.start()
            .withUri('/api/email/template')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves a single event log for the given Id.
     *
     * @param {number} eventLogId The Id of the event log to retrieve.
     * @returns {Promise<ClientResponse<EventLogResponse>>}
     */
    retrieveEventLog(eventLogId) {
        return this.start()
            .withUri('/api/system/event-log')
            .withUriSegment(eventLogId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the families that a user belongs to.
     *
     * @param {string} userId The User's id
     * @returns {Promise<ClientResponse<FamilyResponse>>}
     */
    retrieveFamilies(userId) {
        return this.start()
            .withUri('/api/user/family')
            .withParameter('userId', userId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the members of a family by the unique Family Id.
     *
     * @param {string} familyId The unique Id of the Family.
     * @returns {Promise<ClientResponse<FamilyResponse>>}
     */
    retrieveFamilyMembersByFamilyId(familyId) {
        return this.start()
            .withUri('/api/user/family')
            .withUriSegment(familyId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the group for the given Id.
     *
     * @param {string} groupId The Id of the group.
     * @returns {Promise<ClientResponse<GroupResponse>>}
     */
    retrieveGroup(groupId) {
        return this.start()
            .withUri('/api/group')
            .withUriSegment(groupId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the groups.
     *
     * @returns {Promise<ClientResponse<GroupResponse>>}
     */
    retrieveGroups() {
        return this.start()
            .withUri('/api/group')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the identity provider for the given id or all of the identity providers if the id is null.
     *
     * @param {string} identityProviderId (Optional) The identity provider id.
     * @returns {Promise<ClientResponse<IdentityProviderResponse>>}
     */
    retrieveIdentityProvider(identityProviderId) {
        return this.start()
            .withUri('/api/identity-provider')
            .withUriSegment(identityProviderId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the identity providers.
     *
     * @returns {Promise<ClientResponse<IdentityProviderResponse>>}
     */
    retrieveIdentityProviders() {
        return this.start()
            .withUri('/api/identity-provider')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the actions for the user with the given Id that are currently inactive.
     * An inactive action means one that is time based and has been canceled or has expired, or is not time based.
     *
     * @param {string} userId The Id of the user to fetch the actions for.
     * @returns {Promise<ClientResponse<ActionResponse>>}
     */
    retrieveInactiveActions(userId) {
        return this.start()
            .withUri('/api/user/action')
            .withParameter('userId', userId)
            .withParameter('active', false)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the applications that are currently inactive.
     *
     * @returns {Promise<ClientResponse<ApplicationResponse>>}
     */
    retrieveInactiveApplications() {
        return this.start()
            .withUri('/api/application')
            .withParameter('inactive', true)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the user actions that are currently inactive.
     *
     * @returns {Promise<ClientResponse<UserActionResponse>>}
     */
    retrieveInactiveUserActions() {
        return this.start()
            .withUri('/api/user-action')
            .withParameter('inactive', true)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the available integrations.
     *
     * @returns {Promise<ClientResponse<IntegrationResponse>>}
     */
    retrieveIntegration() {
        return this.start()
            .withUri('/api/integration')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the Public Key configured for verifying JSON Web Tokens (JWT) by the key Id (kid).
     *
     * @param {string} keyId The Id of the public key (kid).
     * @returns {Promise<ClientResponse<PublicKeyResponse>>}
     */
    retrieveJWTPublicKey(keyId) {
        return this.start()
            .withUri('/api/jwt/public-key')
            .withParameter('kid', keyId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the Public Key configured for verifying the JSON Web Tokens (JWT) issued by the Login API by the Application Id.
     *
     * @param {string} applicationId The Id of the Application for which this key is used.
     * @returns {Promise<ClientResponse<PublicKeyResponse>>}
     */
    retrieveJWTPublicKeyByApplicationId(applicationId) {
        return this.start()
            .withUri('/api/jwt/public-key')
            .withParameter('applicationId', applicationId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all Public Keys configured for verifying JSON Web Tokens (JWT).
     *
     * @returns {Promise<ClientResponse<PublicKeyResponse>>}
     */
    retrieveJWTPublicKeys() {
        return this.start()
            .withUri('/api/jwt/public-key')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the key for the given Id.
     *
     * @param {string} keyId The Id of the key.
     * @returns {Promise<ClientResponse<KeyResponse>>}
     */
    retrieveKey(keyId) {
        return this.start()
            .withUri('/api/key')
            .withUriSegment(keyId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the keys.
     *
     * @returns {Promise<ClientResponse<KeyResponse>>}
     */
    retrieveKeys() {
        return this.start()
            .withUri('/api/key')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the lambda for the given Id.
     *
     * @param {string} lambdaId The Id of the lambda.
     * @returns {Promise<ClientResponse<LambdaResponse>>}
     */
    retrieveLambda(lambdaId) {
        return this.start()
            .withUri('/api/lambda')
            .withUriSegment(lambdaId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the lambdas.
     *
     * @returns {Promise<ClientResponse<LambdaResponse>>}
     */
    retrieveLambdas() {
        return this.start()
            .withUri('/api/lambda')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the lambdas for the provided type.
     *
     * @param {LambdaType} type The type of the lambda to return.
     * @returns {Promise<ClientResponse<LambdaResponse>>}
     */
    retrieveLambdasByType(type) {
        return this.start()
            .withUri('/api/lambda')
            .withParameter('type', type)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the login report between the two instants. If you specify an application id, it will only return the
     * login counts for that application.
     *
     * @param {string} applicationId (Optional) The application id.
     * @param {number} start The start instant as UTC milliseconds since Epoch.
     * @param {number} end The end instant as UTC milliseconds since Epoch.
     * @returns {Promise<ClientResponse<LoginReportResponse>>}
     */
    retrieveLoginReport(applicationId, start, end) {
        return this.start()
            .withUri('/api/report/login')
            .withParameter('applicationId', applicationId)
            .withParameter('start', start)
            .withParameter('end', end)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the monthly active user report between the two instants. If you specify an application id, it will only
     * return the monthly active counts for that application.
     *
     * @param {string} applicationId (Optional) The application id.
     * @param {number} start The start instant as UTC milliseconds since Epoch.
     * @param {number} end The end instant as UTC milliseconds since Epoch.
     * @returns {Promise<ClientResponse<MonthlyActiveUserReportResponse>>}
     */
    retrieveMonthlyActiveReport(applicationId, start, end) {
        return this.start()
            .withUri('/api/report/monthly-active-user')
            .withParameter('applicationId', applicationId)
            .withParameter('start', start)
            .withParameter('end', end)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the Oauth2 configuration for the application for the given Application Id.
     *
     * @param {string} applicationId The Id of the Application to retrieve OAuth configuration.
     * @returns {Promise<ClientResponse<OAuthConfigurationResponse>>}
     */
    retrieveOauthConfiguration(applicationId) {
        return this.start()
            .withUri('/api/application')
            .withUriSegment(applicationId)
            .withUriSegment("oauth-configuration")
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the password validation rules for a specific tenant. This method requires a tenantId to be provided
     * through the use of a Tenant scoped API key or an HTTP header X-FusionAuth-TenantId to specify the Tenant Id.
     *
     * This API does not require an API key.
     *
     * @returns {Promise<ClientResponse<PasswordValidationRulesResponse>>}
     */
    retrievePasswordValidationRules() {
        return this.start()
            .withUri('/api/tenant/password-validation-rules')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the password validation rules for a specific tenant.
     *
     * This API does not require an API key.
     *
     * @param {string} tenantId The Id of the tenant.
     * @returns {Promise<ClientResponse<PasswordValidationRulesResponse>>}
     */
    retrievePasswordValidationRulesWithTenantId(tenantId) {
        return this.start()
            .withUri('/api/tenant/password-validation-rules')
            .withUriSegment(tenantId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the children for the given parent email address.
     *
     * @param {string} parentEmail The email of the parent.
     * @returns {Promise<ClientResponse<PendingResponse>>}
     */
    retrievePendingChildren(parentEmail) {
        return this.start()
            .withUri('/api/user/family/pending')
            .withParameter('parentEmail', parentEmail)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the last number of login records.
     *
     * @param {number} offset The initial record. e.g. 0 is the last login, 100 will be the 100th most recent login.
     * @param {number} limit (Optional, defaults to 10) The number of records to retrieve.
     * @returns {Promise<ClientResponse<RecentLoginResponse>>}
     */
    retrieveRecentLogins(offset, limit) {
        return this.start()
            .withUri('/api/user/recent-login')
            .withParameter('offset', offset)
            .withParameter('limit', limit)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the refresh tokens that belong to the user with the given Id.
     *
     * @param {string} userId The Id of the user.
     * @returns {Promise<ClientResponse<RefreshResponse>>}
     */
    retrieveRefreshTokens(userId) {
        return this.start()
            .withUri('/api/jwt/refresh')
            .withParameter('userId', userId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the user registration for the user with the given id and the given application id.
     *
     * @param {string} userId The Id of the user.
     * @param {string} applicationId The Id of the application.
     * @returns {Promise<ClientResponse<RegistrationResponse>>}
     */
    retrieveRegistration(userId, applicationId) {
        return this.start()
            .withUri('/api/user/registration')
            .withUriSegment(userId)
            .withUriSegment(applicationId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the registration report between the two instants. If you specify an application id, it will only return
     * the registration counts for that application.
     *
     * @param {string} applicationId (Optional) The application id.
     * @param {number} start The start instant as UTC milliseconds since Epoch.
     * @param {number} end The end instant as UTC milliseconds since Epoch.
     * @returns {Promise<ClientResponse<RegistrationReportResponse>>}
     */
    retrieveRegistrationReport(applicationId, start, end) {
        return this.start()
            .withUri('/api/report/registration')
            .withParameter('applicationId', applicationId)
            .withParameter('start', start)
            .withParameter('end', end)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the system configuration.
     *
     * @returns {Promise<ClientResponse<SystemConfigurationResponse>>}
     */
    retrieveSystemConfiguration() {
        return this.start()
            .withUri('/api/system-configuration')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the tenant for the given Id.
     *
     * @param {string} tenantId The Id of the tenant.
     * @returns {Promise<ClientResponse<TenantResponse>>}
     */
    retrieveTenant(tenantId) {
        return this.start()
            .withUri('/api/tenant')
            .withUriSegment(tenantId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the tenants.
     *
     * @returns {Promise<ClientResponse<TenantResponse>>}
     */
    retrieveTenants() {
        return this.start()
            .withUri('/api/tenant')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the theme for the given Id.
     *
     * @param {string} themeId The Id of the theme.
     * @returns {Promise<ClientResponse<ThemeResponse>>}
     */
    retrieveTheme(themeId) {
        return this.start()
            .withUri('/api/theme')
            .withUriSegment(themeId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the themes.
     *
     * @returns {Promise<ClientResponse<ThemeResponse>>}
     */
    retrieveThemes() {
        return this.start()
            .withUri('/api/theme')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the totals report. This contains all of the total counts for each application and the global registration
     * count.
     *
     * @returns {Promise<ClientResponse<TotalsReportResponse>>}
     */
    retrieveTotalReport() {
        return this.start()
            .withUri('/api/report/totals')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the user for the given Id.
     *
     * @param {string} userId The Id of the user.
     * @returns {Promise<ClientResponse<UserResponse>>}
     */
    retrieveUser(userId) {
        return this.start()
            .withUri('/api/user')
            .withUriSegment(userId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the user action for the given Id. If you pass in null for the id, this will return all of the user
     * actions.
     *
     * @param {string} userActionId (Optional) The Id of the user action.
     * @returns {Promise<ClientResponse<UserActionResponse>>}
     */
    retrieveUserAction(userActionId) {
        return this.start()
            .withUri('/api/user-action')
            .withUriSegment(userActionId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the user action reason for the given Id. If you pass in null for the id, this will return all of the user
     * action reasons.
     *
     * @param {string} userActionReasonId (Optional) The Id of the user action reason.
     * @returns {Promise<ClientResponse<UserActionReasonResponse>>}
     */
    retrieveUserActionReason(userActionReasonId) {
        return this.start()
            .withUri('/api/user-action-reason')
            .withUriSegment(userActionReasonId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all the user action reasons.
     *
     * @returns {Promise<ClientResponse<UserActionReasonResponse>>}
     */
    retrieveUserActionReasons() {
        return this.start()
            .withUri('/api/user-action-reason')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the user actions.
     *
     * @returns {Promise<ClientResponse<UserActionResponse>>}
     */
    retrieveUserActions() {
        return this.start()
            .withUri('/api/user-action')
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the user by a change password Id. The intended use of this API is to retrieve a user after the forgot
     * password workflow has been initiated and you may not know the user's email or username.
     *
     * @param {string} changePasswordId The unique change password Id that was sent via email or returned by the Forgot Password API.
     * @returns {Promise<ClientResponse<UserResponse>>}
     */
    retrieveUserByChangePasswordId(changePasswordId) {
        return this.start()
            .withUri('/api/user')
            .withParameter('changePasswordId', changePasswordId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the user for the given email.
     *
     * @param {string} email The email of the user.
     * @returns {Promise<ClientResponse<UserResponse>>}
     */
    retrieveUserByEmail(email) {
        return this.start()
            .withUri('/api/user')
            .withParameter('email', email)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the user for the loginId. The loginId can be either the username or the email.
     *
     * @param {string} loginId The email or username of the user.
     * @returns {Promise<ClientResponse<UserResponse>>}
     */
    retrieveUserByLoginId(loginId) {
        return this.start()
            .withUri('/api/user')
            .withParameter('loginId', loginId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the user for the given username.
     *
     * @param {string} username The username of the user.
     * @returns {Promise<ClientResponse<UserResponse>>}
     */
    retrieveUserByUsername(username) {
        return this.start()
            .withUri('/api/user')
            .withParameter('username', username)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the user by a verificationId. The intended use of this API is to retrieve a user after the forgot
     * password workflow has been initiated and you may not know the user's email or username.
     *
     * @param {string} verificationId The unique verification Id that has been set on the user object.
     * @returns {Promise<ClientResponse<UserResponse>>}
     */
    retrieveUserByVerificationId(verificationId) {
        return this.start()
            .withUri('/api/user')
            .withParameter('verificationId', verificationId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the comments for the user with the given Id.
     *
     * @param {string} userId The Id of the user.
     * @returns {Promise<ClientResponse<UserCommentResponse>>}
     */
    retrieveUserComments(userId) {
        return this.start()
            .withUri('/api/user/comment')
            .withUriSegment(userId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieve a single User consent by Id.
     *
     * @param {string} userConsentId The User consent Id
     * @returns {Promise<ClientResponse<UserConsentResponse>>}
     */
    retrieveUserConsent(userConsentId) {
        return this.start()
            .withUri('/api/user/consent')
            .withUriSegment(userConsentId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all of the consents for a User.
     *
     * @param {string} userId The User's Id
     * @returns {Promise<ClientResponse<UserConsentResponse>>}
     */
    retrieveUserConsents(userId) {
        return this.start()
            .withUri('/api/user/consent')
            .withParameter('userId', userId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the login report between the two instants for a particular user by Id. If you specify an application id, it will only return the
     * login counts for that application.
     *
     * @param {string} applicationId (Optional) The application id.
     * @param {string} userId The userId id.
     * @param {number} start The start instant as UTC milliseconds since Epoch.
     * @param {number} end The end instant as UTC milliseconds since Epoch.
     * @returns {Promise<ClientResponse<LoginReportResponse>>}
     */
    retrieveUserLoginReport(applicationId, userId, start, end) {
        return this.start()
            .withUri('/api/report/login')
            .withParameter('applicationId', applicationId)
            .withParameter('userId', userId)
            .withParameter('start', start)
            .withParameter('end', end)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the login report between the two instants for a particular user by login Id. If you specify an application id, it will only return the
     * login counts for that application.
     *
     * @param {string} applicationId (Optional) The application id.
     * @param {string} loginId The userId id.
     * @param {number} start The start instant as UTC milliseconds since Epoch.
     * @param {number} end The end instant as UTC milliseconds since Epoch.
     * @returns {Promise<ClientResponse<LoginReportResponse>>}
     */
    retrieveUserLoginReportByLoginId(applicationId, loginId, start, end) {
        return this.start()
            .withUri('/api/report/login')
            .withParameter('applicationId', applicationId)
            .withParameter('loginId', loginId)
            .withParameter('start', start)
            .withParameter('end', end)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the last number of login records for a user.
     *
     * @param {string} userId The Id of the user.
     * @param {number} offset The initial record. e.g. 0 is the last login, 100 will be the 100th most recent login.
     * @param {number} limit (Optional, defaults to 10) The number of records to retrieve.
     * @returns {Promise<ClientResponse<RecentLoginResponse>>}
     */
    retrieveUserRecentLogins(userId, offset, limit) {
        return this.start()
            .withUri('/api/user/recent-login')
            .withParameter('userId', userId)
            .withParameter('offset', offset)
            .withParameter('limit', limit)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the user for the given Id. This method does not use an API key, instead it uses a JSON Web Token (JWT) for authentication.
     *
     * @param {string} encodedJWT The encoded JWT (access token).
     * @returns {Promise<ClientResponse<UserResponse>>}
     */
    retrieveUserUsingJWT(encodedJWT) {
        return this.start()
            .withUri('/api/user')
            .withAuthorization('JWT ' + encodedJWT)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the webhook for the given Id. If you pass in null for the id, this will return all the webhooks.
     *
     * @param {string} webhookId (Optional) The Id of the webhook.
     * @returns {Promise<ClientResponse<WebhookResponse>>}
     */
    retrieveWebhook(webhookId) {
        return this.start()
            .withUri('/api/webhook')
            .withUriSegment(webhookId)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves all the webhooks.
     *
     * @returns {Promise<ClientResponse<WebhookResponse>>}
     */
    retrieveWebhooks() {
        return this.start()
            .withUri('/api/webhook')
            .withMethod("GET")
            .go();
    }
    /**
     * Revokes a single refresh token, all tokens for a user or all tokens for an application. If you provide a user id
     * and an application id, this will delete all the refresh tokens for that user for that application.
     *
     * @param {string} token (Optional) The refresh token to delete.
     * @param {string} userId (Optional) The user id whose tokens to delete.
     * @param {string} applicationId (Optional) The application id of the tokens to delete.
     * @returns {Promise<ClientResponse<void>>}
     */
    revokeRefreshToken(token, userId, applicationId) {
        return this.start()
            .withUri('/api/jwt/refresh')
            .withParameter('token', token)
            .withParameter('userId', userId)
            .withParameter('applicationId', applicationId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Revokes a single User consent by Id.
     *
     * @param {string} userConsentId The User Consent Id
     * @returns {Promise<ClientResponse<void>>}
     */
    revokeUserConsent(userConsentId) {
        return this.start()
            .withUri('/api/user/consent')
            .withUriSegment(userConsentId)
            .withMethod("DELETE")
            .go();
    }
    /**
     * Searches the audit logs with the specified criteria and pagination.
     *
     * @param {AuditLogSearchRequest} request The search criteria and pagination information.
     * @returns {Promise<ClientResponse<AuditLogSearchResponse>>}
     */
    searchAuditLogs(request) {
        return this.start()
            .withUri('/api/system/audit-log/search')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Searches the event logs with the specified criteria and pagination.
     *
     * @param {EventLogSearchRequest} request The search criteria and pagination information.
     * @returns {Promise<ClientResponse<EventLogSearchResponse>>}
     */
    searchEventLogs(request) {
        return this.start()
            .withUri('/api/system/event-log/search')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Searches the login records with the specified criteria and pagination.
     *
     * @param {LoginRecordSearchRequest} request The search criteria and pagination information.
     * @returns {Promise<ClientResponse<LoginRecordSearchResponse>>}
     */
    searchLoginRecords(request) {
        return this.start()
            .withUri('/api/system/login-record/search')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Retrieves the users for the given ids. If any id is invalid, it is ignored.
     *
     * @param {Array<string>} ids The user ids to search for.
     * @returns {Promise<ClientResponse<SearchResponse>>}
     */
    searchUsers(ids) {
        return this.start()
            .withUri('/api/user/search')
            .withParameter('ids', ids)
            .withMethod("GET")
            .go();
    }
    /**
     * Retrieves the users for the given search criteria and pagination.
     *
     * @param {SearchRequest} request The search criteria and pagination constraints. Fields used: queryString, numberOfResults, startRow,
     *    and sort fields.
     * @returns {Promise<ClientResponse<SearchResponse>>}
     */
    searchUsersByQueryString(request) {
        return this.start()
            .withUri('/api/user/search')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Send an email using an email template id. You can optionally provide <code>requestData</code> to access key value
     * pairs in the email template.
     *
     * @param {string} emailTemplateId The id for the template.
     * @param {SendRequest} request The send email request that contains all of the information used to send the email.
     * @returns {Promise<ClientResponse<SendResponse>>}
     */
    sendEmail(emailTemplateId, request) {
        return this.start()
            .withUri('/api/email/send')
            .withUriSegment(emailTemplateId)
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Sends out an email to a parent that they need to register and create a family or need to log in and add a child to their existing family.
     *
     * @param {FamilyEmailRequest} request The request object that contains the parent email.
     * @returns {Promise<ClientResponse<void>>}
     */
    sendFamilyRequestEmail(request) {
        return this.start()
            .withUri('/api/user/family/request')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Send a passwordless authentication code in an email to complete login.
     *
     * @param {PasswordlessSendRequest} request The passwordless send request that contains all of the information used to send an email containing a code.
     * @returns {Promise<ClientResponse<void>>}
     */
    sendPasswordlessCode(request) {
        return this.start()
            .withUri('/api/passwordless/send')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Send a Two Factor authentication code to assist in setting up Two Factor authentication or disabling.
     *
     * @param {TwoFactorSendRequest} request The request object that contains all of the information used to send the code.
     * @returns {Promise<ClientResponse<void>>}
     */
    sendTwoFactorCode(request) {
        return this.start()
            .withUri('/api/two-factor/send')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Send a Two Factor authentication code to allow the completion of Two Factor authentication.
     *
     * @param {string} twoFactorId The Id returned by the Login API necessary to complete Two Factor authentication.
     * @returns {Promise<ClientResponse<void>>}
     */
    sendTwoFactorCodeForLogin(twoFactorId) {
        return this.start()
            .withHeader('Content-Type', 'text/plain')
            .withUri('/api/two-factor/send')
            .withUriSegment(twoFactorId)
            .withMethod("POST")
            .go();
    }
    /**
     * Complete login using a 2FA challenge
     *
     * @param {TwoFactorLoginRequest} request The login request that contains the user credentials used to log them in.
     * @returns {Promise<ClientResponse<LoginResponse>>}
     */
    twoFactorLogin(request) {
        return this.start()
            .withUri('/api/two-factor/login')
            .withJSONBody(request)
            .withMethod("POST")
            .go();
    }
    /**
     * Updates the application with the given Id.
     *
     * @param {string} applicationId The Id of the application to update.
     * @param {ApplicationRequest} request The request that contains all of the new application information.
     * @returns {Promise<ClientResponse<ApplicationResponse>>}
     */
    updateApplication(applicationId, request) {
        return this.start()
            .withUri('/api/application')
            .withUriSegment(applicationId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the application role with the given id for the application.
     *
     * @param {string} applicationId The Id of the application that the role belongs to.
     * @param {string} roleId The Id of the role to update.
     * @param {ApplicationRequest} request The request that contains all of the new role information.
     * @returns {Promise<ClientResponse<ApplicationResponse>>}
     */
    updateApplicationRole(applicationId, roleId, request) {
        return this.start()
            .withUri('/api/application')
            .withUriSegment(applicationId)
            .withUriSegment("role")
            .withUriSegment(roleId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the consent with the given Id.
     *
     * @param {string} consentId The Id of the consent to update.
     * @param {ConsentRequest} request The request that contains all of the new consent information.
     * @returns {Promise<ClientResponse<ConsentResponse>>}
     */
    updateConsent(consentId, request) {
        return this.start()
            .withUri('/api/consent')
            .withUriSegment(consentId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the email template with the given Id.
     *
     * @param {string} emailTemplateId The Id of the email template to update.
     * @param {EmailTemplateRequest} request The request that contains all of the new email template information.
     * @returns {Promise<ClientResponse<EmailTemplateResponse>>}
     */
    updateEmailTemplate(emailTemplateId, request) {
        return this.start()
            .withUri('/api/email/template')
            .withUriSegment(emailTemplateId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the group with the given Id.
     *
     * @param {string} groupId The Id of the group to update.
     * @param {GroupRequest} request The request that contains all of the new group information.
     * @returns {Promise<ClientResponse<GroupResponse>>}
     */
    updateGroup(groupId, request) {
        return this.start()
            .withUri('/api/group')
            .withUriSegment(groupId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the identity provider with the given Id.
     *
     * @param {string} identityProviderId The Id of the identity provider to update.
     * @param {IdentityProviderRequest} request The request object that contains the updated identity provider.
     * @returns {Promise<ClientResponse<IdentityProviderResponse>>}
     */
    updateIdentityProvider(identityProviderId, request) {
        return this.start()
            .withUri('/api/identity-provider')
            .withUriSegment(identityProviderId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the available integrations.
     *
     * @param {IntegrationRequest} request The request that contains all of the new integration information.
     * @returns {Promise<ClientResponse<IntegrationResponse>>}
     */
    updateIntegrations(request) {
        return this.start()
            .withUri('/api/integration')
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the key with the given Id.
     *
     * @param {string} keyId The Id of the key to update.
     * @param {KeyRequest} request The request that contains all of the new key information.
     * @returns {Promise<ClientResponse<KeyResponse>>}
     */
    updateKey(keyId, request) {
        return this.start()
            .withUri('/api/key')
            .withUriSegment(keyId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the lambda with the given Id.
     *
     * @param {string} lambdaId The Id of the lambda to update.
     * @param {LambdaRequest} request The request that contains all of the new lambda information.
     * @returns {Promise<ClientResponse<LambdaResponse>>}
     */
    updateLambda(lambdaId, request) {
        return this.start()
            .withUri('/api/lambda')
            .withUriSegment(lambdaId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the registration for the user with the given id and the application defined in the request.
     *
     * @param {string} userId The Id of the user whose registration is going to be updated.
     * @param {RegistrationRequest} request The request that contains all of the new registration information.
     * @returns {Promise<ClientResponse<RegistrationResponse>>}
     */
    updateRegistration(userId, request) {
        return this.start()
            .withUri('/api/user/registration')
            .withUriSegment(userId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the system configuration.
     *
     * @param {SystemConfigurationRequest} request The request that contains all of the new system configuration information.
     * @returns {Promise<ClientResponse<SystemConfigurationResponse>>}
     */
    updateSystemConfiguration(request) {
        return this.start()
            .withUri('/api/system-configuration')
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the tenant with the given Id.
     *
     * @param {string} tenantId The Id of the tenant to update.
     * @param {TenantRequest} request The request that contains all of the new tenant information.
     * @returns {Promise<ClientResponse<TenantResponse>>}
     */
    updateTenant(tenantId, request) {
        return this.start()
            .withUri('/api/tenant')
            .withUriSegment(tenantId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the theme with the given Id.
     *
     * @param {string} themeId The Id of the theme to update.
     * @param {ThemeRequest} request The request that contains all of the new theme information.
     * @returns {Promise<ClientResponse<ThemeResponse>>}
     */
    updateTheme(themeId, request) {
        return this.start()
            .withUri('/api/theme')
            .withUriSegment(themeId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the user with the given Id.
     *
     * @param {string} userId The Id of the user to update.
     * @param {UserRequest} request The request that contains all of the new user information.
     * @returns {Promise<ClientResponse<UserResponse>>}
     */
    updateUser(userId, request) {
        return this.start()
            .withUri('/api/user')
            .withUriSegment(userId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the user action with the given Id.
     *
     * @param {string} userActionId The Id of the user action to update.
     * @param {UserActionRequest} request The request that contains all of the new user action information.
     * @returns {Promise<ClientResponse<UserActionResponse>>}
     */
    updateUserAction(userActionId, request) {
        return this.start()
            .withUri('/api/user-action')
            .withUriSegment(userActionId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the user action reason with the given Id.
     *
     * @param {string} userActionReasonId The Id of the user action reason to update.
     * @param {UserActionReasonRequest} request The request that contains all of the new user action reason information.
     * @returns {Promise<ClientResponse<UserActionReasonResponse>>}
     */
    updateUserActionReason(userActionReasonId, request) {
        return this.start()
            .withUri('/api/user-action-reason')
            .withUriSegment(userActionReasonId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates a single User consent by Id.
     *
     * @param {string} userConsentId The User Consent Id
     * @param {UserConsentRequest} request The request that contains the user consent information.
     * @returns {Promise<ClientResponse<UserConsentResponse>>}
     */
    updateUserConsent(userConsentId, request) {
        return this.start()
            .withUri('/api/user/consent')
            .withUriSegment(userConsentId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Updates the webhook with the given Id.
     *
     * @param {string} webhookId The Id of the webhook to update.
     * @param {WebhookRequest} request The request that contains all of the new webhook information.
     * @returns {Promise<ClientResponse<WebhookResponse>>}
     */
    updateWebhook(webhookId, request) {
        return this.start()
            .withUri('/api/webhook')
            .withUriSegment(webhookId)
            .withJSONBody(request)
            .withMethod("PUT")
            .go();
    }
    /**
     * Validates the provided JWT (encoded JWT string) to ensure the token is valid. A valid access token is properly
     * signed and not expired.
     * <p>
     * This API may be used to verify the JWT as well as decode the encoded JWT into human readable identity claims.
     *
     * @param {string} encodedJWT The encoded JWT (access token).
     * @returns {Promise<ClientResponse<ValidateResponse>>}
     */
    validateJWT(encodedJWT) {
        return this.start()
            .withUri('/api/jwt/validate')
            .withAuthorization('JWT ' + encodedJWT)
            .withMethod("GET")
            .go();
    }
    /**
     * Confirms a email verification. The Id given is usually from an email sent to the user.
     *
     * @param {string} verificationId The email verification id sent to the user.
     * @returns {Promise<ClientResponse<void>>}
     */
    verifyEmail(verificationId) {
        return this.start()
            .withHeader('Content-Type', 'text/plain')
            .withUri('/api/user/verify-email')
            .withUriSegment(verificationId)
            .withMethod("POST")
            .go();
    }
    /**
     * Confirms an application registration. The Id given is usually from an email sent to the user.
     *
     * @param {string} verificationId The registration verification Id sent to the user.
     * @returns {Promise<ClientResponse<void>>}
     */
    verifyRegistration(verificationId) {
        return this.start()
            .withHeader('Content-Type', 'text/plain')
            .withUri('/api/user/verify-registration')
            .withUriSegment(verificationId)
            .withMethod("POST")
            .go();
    }
    /* ===================================================================================================================
     * Private methods
     * ===================================================================================================================*/
    /**
     * creates a rest client
     *
     * @returns {IRestClient} The RESTClient that will be used to call.
     * @private
     */
    start() {
        let client = this.clientBuilder.build(this.host).withAuthorization(this.apiKey);
        if (this.tenantId !== null && typeof (this.tenantId) !== 'undefined') {
            client.withHeader('X-FusionAuth-TenantId', this.tenantId);
        }
        if (this.credentials != null) {
            client.withCredentials(this.credentials);
        }
        return client;
    }
}
/**
 * Available JSON Web Algorithms (JWA) as described in RFC 7518 available for this JWT implementation.
 *
 * @author Daniel DeGroff
 */
var Algorithm;
(function (Algorithm) {
    Algorithm[Algorithm["ES256"] = 0] = "ES256";
    Algorithm[Algorithm["ES384"] = 1] = "ES384";
    Algorithm[Algorithm["ES512"] = 2] = "ES512";
    Algorithm[Algorithm["HS256"] = 3] = "HS256";
    Algorithm[Algorithm["HS384"] = 4] = "HS384";
    Algorithm[Algorithm["HS512"] = 5] = "HS512";
    Algorithm[Algorithm["RS256"] = 6] = "RS256";
    Algorithm[Algorithm["RS384"] = 7] = "RS384";
    Algorithm[Algorithm["RS512"] = 8] = "RS512";
    Algorithm[Algorithm["none"] = 9] = "none";
})(Algorithm = exports.Algorithm || (exports.Algorithm = {}));
var CanonicalizationMethod;
(function (CanonicalizationMethod) {
    CanonicalizationMethod[CanonicalizationMethod["exclusive"] = 0] = "exclusive";
    CanonicalizationMethod[CanonicalizationMethod["exclusive_with_comments"] = 1] = "exclusive_with_comments";
    CanonicalizationMethod[CanonicalizationMethod["inclusive"] = 2] = "inclusive";
    CanonicalizationMethod[CanonicalizationMethod["inclusive_with_comments"] = 3] = "inclusive_with_comments";
})(CanonicalizationMethod = exports.CanonicalizationMethod || (exports.CanonicalizationMethod = {}));
/**
 * Models a consent.
 *
 * @author Daniel DeGroff
 */
var ConsentStatus;
(function (ConsentStatus) {
    ConsentStatus[ConsentStatus["Active"] = 0] = "Active";
    ConsentStatus[ConsentStatus["Revoked"] = 1] = "Revoked";
})(ConsentStatus = exports.ConsentStatus || (exports.ConsentStatus = {}));
/**
 * Status for content like usernames, profile attributes, etc.
 *
 * @author Brian Pontarelli
 */
var ContentStatus;
(function (ContentStatus) {
    ContentStatus[ContentStatus["ACTIVE"] = 0] = "ACTIVE";
    ContentStatus[ContentStatus["PENDING"] = 1] = "PENDING";
    ContentStatus[ContentStatus["REJECTED"] = 2] = "REJECTED";
})(ContentStatus = exports.ContentStatus || (exports.ContentStatus = {}));
var DeviceType;
(function (DeviceType) {
    DeviceType[DeviceType["BROWSER"] = 0] = "BROWSER";
    DeviceType[DeviceType["DESKTOP"] = 1] = "DESKTOP";
    DeviceType[DeviceType["LAPTOP"] = 2] = "LAPTOP";
    DeviceType[DeviceType["MOBILE"] = 3] = "MOBILE";
    DeviceType[DeviceType["OTHER"] = 4] = "OTHER";
    DeviceType[DeviceType["SERVER"] = 5] = "SERVER";
    DeviceType[DeviceType["TABLET"] = 6] = "TABLET";
    DeviceType[DeviceType["TV"] = 7] = "TV";
    DeviceType[DeviceType["UNKNOWN"] = 8] = "UNKNOWN";
})(DeviceType = exports.DeviceType || (exports.DeviceType = {}));
var EmailSecurityType;
(function (EmailSecurityType) {
    EmailSecurityType[EmailSecurityType["NONE"] = 0] = "NONE";
    EmailSecurityType[EmailSecurityType["SSL"] = 1] = "SSL";
    EmailSecurityType[EmailSecurityType["TLS"] = 2] = "TLS";
})(EmailSecurityType = exports.EmailSecurityType || (exports.EmailSecurityType = {}));
/**
 * Event Log Type
 *
 * @author Daniel DeGroff
 */
var EventLogType;
(function (EventLogType) {
    EventLogType[EventLogType["Information"] = 0] = "Information";
    EventLogType[EventLogType["Debug"] = 1] = "Debug";
    EventLogType[EventLogType["Error"] = 2] = "Error";
})(EventLogType = exports.EventLogType || (exports.EventLogType = {}));
/**
 * Models the event types that FusionAuth produces.
 *
 * @author Brian Pontarelli
 */
var EventType;
(function (EventType) {
    EventType[EventType["UserDelete"] = 0] = "UserDelete";
    EventType[EventType["UserCreate"] = 1] = "UserCreate";
    EventType[EventType["UserUpdate"] = 2] = "UserUpdate";
    EventType[EventType["UserDeactivate"] = 3] = "UserDeactivate";
    EventType[EventType["UserBulkCreate"] = 4] = "UserBulkCreate";
    EventType[EventType["UserReactivate"] = 5] = "UserReactivate";
    EventType[EventType["UserAction"] = 6] = "UserAction";
    EventType[EventType["JWTRefreshTokenRevoke"] = 7] = "JWTRefreshTokenRevoke";
    EventType[EventType["JWTPublicKeyUpdate"] = 8] = "JWTPublicKeyUpdate";
    EventType[EventType["UserLoginSuccess"] = 9] = "UserLoginSuccess";
    EventType[EventType["UserLoginFailed"] = 10] = "UserLoginFailed";
    EventType[EventType["UserRegistrationCreate"] = 11] = "UserRegistrationCreate";
    EventType[EventType["UserRegistrationUpdate"] = 12] = "UserRegistrationUpdate";
    EventType[EventType["UserRegistrationDelete"] = 13] = "UserRegistrationDelete";
    EventType[EventType["UserRegistrationVerified"] = 14] = "UserRegistrationVerified";
    EventType[EventType["UserEmailVerified"] = 15] = "UserEmailVerified";
    EventType[EventType["Test"] = 16] = "Test";
})(EventType = exports.EventType || (exports.EventType = {}));
/**
 * @author Brian Pontarelli
 */
var ExpiryUnit;
(function (ExpiryUnit) {
    ExpiryUnit[ExpiryUnit["MINUTES"] = 0] = "MINUTES";
    ExpiryUnit[ExpiryUnit["HOURS"] = 1] = "HOURS";
    ExpiryUnit[ExpiryUnit["DAYS"] = 2] = "DAYS";
    ExpiryUnit[ExpiryUnit["WEEKS"] = 3] = "WEEKS";
    ExpiryUnit[ExpiryUnit["MONTHS"] = 4] = "MONTHS";
    ExpiryUnit[ExpiryUnit["YEARS"] = 5] = "YEARS";
})(ExpiryUnit = exports.ExpiryUnit || (exports.ExpiryUnit = {}));
var FamilyRole;
(function (FamilyRole) {
    FamilyRole[FamilyRole["Child"] = 0] = "Child";
    FamilyRole[FamilyRole["Teen"] = 1] = "Teen";
    FamilyRole[FamilyRole["Adult"] = 2] = "Adult";
})(FamilyRole = exports.FamilyRole || (exports.FamilyRole = {}));
/**
 * Authorization Grant types as defined by the <a href="https://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization
 * Framework - RFC 6749</a>.
 * <p>
 * Specific names as defined by <a href="https://tools.ietf.org/html/rfc7591#section-4.1">
 * OAuth 2.0 Dynamic Client Registration Protocol - RFC 7591 Section 4.1</a>
 *
 * @author Daniel DeGroff
 */
var GrantType;
(function (GrantType) {
    GrantType[GrantType["authorization_code"] = 0] = "authorization_code";
    GrantType[GrantType["implicit"] = 1] = "implicit";
    GrantType[GrantType["password"] = 2] = "password";
    GrantType[GrantType["client_credentials"] = 3] = "client_credentials";
    GrantType[GrantType["refresh_token"] = 4] = "refresh_token";
    GrantType[GrantType["unknown"] = 5] = "unknown";
})(GrantType = exports.GrantType || (exports.GrantType = {}));
var HTTPMethod;
(function (HTTPMethod) {
    HTTPMethod[HTTPMethod["GET"] = 0] = "GET";
    HTTPMethod[HTTPMethod["POST"] = 1] = "POST";
    HTTPMethod[HTTPMethod["PUT"] = 2] = "PUT";
    HTTPMethod[HTTPMethod["DELETE"] = 3] = "DELETE";
    HTTPMethod[HTTPMethod["HEAD"] = 4] = "HEAD";
    HTTPMethod[HTTPMethod["OPTIONS"] = 5] = "OPTIONS";
})(HTTPMethod = exports.HTTPMethod || (exports.HTTPMethod = {}));
var IdentityProviderType;
(function (IdentityProviderType) {
    IdentityProviderType[IdentityProviderType["ExternalJWT"] = 0] = "ExternalJWT";
    IdentityProviderType[IdentityProviderType["OpenIDConnect"] = 1] = "OpenIDConnect";
    IdentityProviderType[IdentityProviderType["Facebook"] = 2] = "Facebook";
    IdentityProviderType[IdentityProviderType["Google"] = 3] = "Google";
    IdentityProviderType[IdentityProviderType["Twitter"] = 4] = "Twitter";
    IdentityProviderType[IdentityProviderType["SAMLv2"] = 5] = "SAMLv2";
})(IdentityProviderType = exports.IdentityProviderType || (exports.IdentityProviderType = {}));
var KeyAlgorithm;
(function (KeyAlgorithm) {
    KeyAlgorithm[KeyAlgorithm["ES256"] = 0] = "ES256";
    KeyAlgorithm[KeyAlgorithm["ES384"] = 1] = "ES384";
    KeyAlgorithm[KeyAlgorithm["ES512"] = 2] = "ES512";
    KeyAlgorithm[KeyAlgorithm["HS256"] = 3] = "HS256";
    KeyAlgorithm[KeyAlgorithm["HS384"] = 4] = "HS384";
    KeyAlgorithm[KeyAlgorithm["HS512"] = 5] = "HS512";
    KeyAlgorithm[KeyAlgorithm["RS256"] = 6] = "RS256";
    KeyAlgorithm[KeyAlgorithm["RS384"] = 7] = "RS384";
    KeyAlgorithm[KeyAlgorithm["RS512"] = 8] = "RS512";
})(KeyAlgorithm = exports.KeyAlgorithm || (exports.KeyAlgorithm = {}));
var KeyType;
(function (KeyType) {
    KeyType[KeyType["EC"] = 0] = "EC";
    KeyType[KeyType["RSA"] = 1] = "RSA";
    KeyType[KeyType["HMAC"] = 2] = "HMAC";
})(KeyType = exports.KeyType || (exports.KeyType = {}));
/**
 * The types of lambdas that indicate how they are invoked by FusionAuth.
 *
 * @author Brian Pontarelli
 */
var LambdaType;
(function (LambdaType) {
    LambdaType[LambdaType["JWTPopulate"] = 0] = "JWTPopulate";
    LambdaType[LambdaType["OpenIDReconcile"] = 1] = "OpenIDReconcile";
    LambdaType[LambdaType["SAMLv2Reconcile"] = 2] = "SAMLv2Reconcile";
    LambdaType[LambdaType["SAMLv2Populate"] = 3] = "SAMLv2Populate";
})(LambdaType = exports.LambdaType || (exports.LambdaType = {}));
var LoginIdType;
(function (LoginIdType) {
    LoginIdType[LoginIdType["email"] = 0] = "email";
    LoginIdType[LoginIdType["username"] = 1] = "username";
})(LoginIdType = exports.LoginIdType || (exports.LoginIdType = {}));
var OAuthErrorReason;
(function (OAuthErrorReason) {
    OAuthErrorReason[OAuthErrorReason["auth_code_not_found"] = 0] = "auth_code_not_found";
    OAuthErrorReason[OAuthErrorReason["access_token_malformed"] = 1] = "access_token_malformed";
    OAuthErrorReason[OAuthErrorReason["access_token_expired"] = 2] = "access_token_expired";
    OAuthErrorReason[OAuthErrorReason["access_token_unavailable_for_processing"] = 3] = "access_token_unavailable_for_processing";
    OAuthErrorReason[OAuthErrorReason["access_token_failed_processing"] = 4] = "access_token_failed_processing";
    OAuthErrorReason[OAuthErrorReason["refresh_token_not_found"] = 5] = "refresh_token_not_found";
    OAuthErrorReason[OAuthErrorReason["invalid_client_id"] = 6] = "invalid_client_id";
    OAuthErrorReason[OAuthErrorReason["invalid_user_credentials"] = 7] = "invalid_user_credentials";
    OAuthErrorReason[OAuthErrorReason["invalid_grant_type"] = 8] = "invalid_grant_type";
    OAuthErrorReason[OAuthErrorReason["invalid_origin"] = 9] = "invalid_origin";
    OAuthErrorReason[OAuthErrorReason["invalid_pkce_code_verifier"] = 10] = "invalid_pkce_code_verifier";
    OAuthErrorReason[OAuthErrorReason["invalid_pkce_code_challenge"] = 11] = "invalid_pkce_code_challenge";
    OAuthErrorReason[OAuthErrorReason["invalid_pkce_code_challenge_method"] = 12] = "invalid_pkce_code_challenge_method";
    OAuthErrorReason[OAuthErrorReason["invalid_redirect_uri"] = 13] = "invalid_redirect_uri";
    OAuthErrorReason[OAuthErrorReason["invalid_response_type"] = 14] = "invalid_response_type";
    OAuthErrorReason[OAuthErrorReason["invalid_id_token_hint"] = 15] = "invalid_id_token_hint";
    OAuthErrorReason[OAuthErrorReason["invalid_post_logout_redirect_uri"] = 16] = "invalid_post_logout_redirect_uri";
    OAuthErrorReason[OAuthErrorReason["grant_type_disabled"] = 17] = "grant_type_disabled";
    OAuthErrorReason[OAuthErrorReason["missing_client_id"] = 18] = "missing_client_id";
    OAuthErrorReason[OAuthErrorReason["missing_code"] = 19] = "missing_code";
    OAuthErrorReason[OAuthErrorReason["missing_grant_type"] = 20] = "missing_grant_type";
    OAuthErrorReason[OAuthErrorReason["missing_redirect_uri"] = 21] = "missing_redirect_uri";
    OAuthErrorReason[OAuthErrorReason["missing_refresh_token"] = 22] = "missing_refresh_token";
    OAuthErrorReason[OAuthErrorReason["missing_response_type"] = 23] = "missing_response_type";
    OAuthErrorReason[OAuthErrorReason["missing_token"] = 24] = "missing_token";
    OAuthErrorReason[OAuthErrorReason["login_prevented"] = 25] = "login_prevented";
    OAuthErrorReason[OAuthErrorReason["user_expired"] = 26] = "user_expired";
    OAuthErrorReason[OAuthErrorReason["user_locked"] = 27] = "user_locked";
    OAuthErrorReason[OAuthErrorReason["user_not_found"] = 28] = "user_not_found";
    OAuthErrorReason[OAuthErrorReason["client_authentication_missing"] = 29] = "client_authentication_missing";
    OAuthErrorReason[OAuthErrorReason["invalid_client_authentication_scheme"] = 30] = "invalid_client_authentication_scheme";
    OAuthErrorReason[OAuthErrorReason["invalid_client_authentication"] = 31] = "invalid_client_authentication";
    OAuthErrorReason[OAuthErrorReason["client_id_mismatch"] = 32] = "client_id_mismatch";
    OAuthErrorReason[OAuthErrorReason["unknown"] = 33] = "unknown";
})(OAuthErrorReason = exports.OAuthErrorReason || (exports.OAuthErrorReason = {}));
var OAuthErrorType;
(function (OAuthErrorType) {
    OAuthErrorType[OAuthErrorType["invalid_request"] = 0] = "invalid_request";
    OAuthErrorType[OAuthErrorType["invalid_client"] = 1] = "invalid_client";
    OAuthErrorType[OAuthErrorType["invalid_grant"] = 2] = "invalid_grant";
    OAuthErrorType[OAuthErrorType["invalid_token"] = 3] = "invalid_token";
    OAuthErrorType[OAuthErrorType["unauthorized_client"] = 4] = "unauthorized_client";
    OAuthErrorType[OAuthErrorType["invalid_scope"] = 5] = "invalid_scope";
    OAuthErrorType[OAuthErrorType["server_error"] = 6] = "server_error";
    OAuthErrorType[OAuthErrorType["unsupported_grant_type"] = 7] = "unsupported_grant_type";
    OAuthErrorType[OAuthErrorType["unsupported_response_type"] = 8] = "unsupported_response_type";
    OAuthErrorType[OAuthErrorType["change_password_required"] = 9] = "change_password_required";
    OAuthErrorType[OAuthErrorType["two_factor_required"] = 10] = "two_factor_required";
})(OAuthErrorType = exports.OAuthErrorType || (exports.OAuthErrorType = {}));
/**
 * @author Daniel DeGroff
 */
var SecureGeneratorType;
(function (SecureGeneratorType) {
    SecureGeneratorType[SecureGeneratorType["randomDigits"] = 0] = "randomDigits";
    SecureGeneratorType[SecureGeneratorType["randomBytes"] = 1] = "randomBytes";
})(SecureGeneratorType = exports.SecureGeneratorType || (exports.SecureGeneratorType = {}));
/**
 * @author Daniel DeGroff
 */
var Sort;
(function (Sort) {
    Sort[Sort["asc"] = 0] = "asc";
    Sort[Sort["desc"] = 1] = "desc";
})(Sort = exports.Sort || (exports.Sort = {}));
/**
 * <ul>
 * <li>Bearer Token type as defined by <a href="https://tools.ietf.org/html/rfc6750">RFC 6750</a>.</li>
 * <li>MAC Token type as referenced by <a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a> and
 * <a href="https://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-05">
 * Draft RFC on OAuth 2.0 Message Authentication Code (MAC) Tokens</a>
 * </li>
 * </ul>
 *
 * @author Daniel DeGroff
 */
var TokenType;
(function (TokenType) {
    TokenType[TokenType["Bearer"] = 0] = "Bearer";
    TokenType[TokenType["MAC"] = 1] = "MAC";
})(TokenType = exports.TokenType || (exports.TokenType = {}));
/**
 * The transaction types for Webhooks and other event systems within FusionAuth.
 *
 * @author Brian Pontarelli
 */
var TransactionType;
(function (TransactionType) {
    TransactionType[TransactionType["None"] = 0] = "None";
    TransactionType[TransactionType["Any"] = 1] = "Any";
    TransactionType[TransactionType["SimpleMajority"] = 2] = "SimpleMajority";
    TransactionType[TransactionType["SuperMajority"] = 3] = "SuperMajority";
    TransactionType[TransactionType["AbsoluteMajority"] = 4] = "AbsoluteMajority";
})(TransactionType = exports.TransactionType || (exports.TransactionType = {}));
/**
 * @author Daniel DeGroff
 */
var TwoFactorDelivery;
(function (TwoFactorDelivery) {
    TwoFactorDelivery[TwoFactorDelivery["None"] = 0] = "None";
    TwoFactorDelivery[TwoFactorDelivery["TextMessage"] = 1] = "TextMessage";
})(TwoFactorDelivery = exports.TwoFactorDelivery || (exports.TwoFactorDelivery = {}));
/**
 * The phases of a time-based user action.
 *
 * @author Brian Pontarelli
 */
var UserActionPhase;
(function (UserActionPhase) {
    UserActionPhase[UserActionPhase["start"] = 0] = "start";
    UserActionPhase[UserActionPhase["modify"] = 1] = "modify";
    UserActionPhase[UserActionPhase["cancel"] = 2] = "cancel";
    UserActionPhase[UserActionPhase["end"] = 3] = "end";
})(UserActionPhase = exports.UserActionPhase || (exports.UserActionPhase = {}));
/**
 * @author Daniel DeGroff
 */
var UserState;
(function (UserState) {
    UserState[UserState["Authenticated"] = 0] = "Authenticated";
    UserState[UserState["AuthenticatedNotRegistered"] = 1] = "AuthenticatedNotRegistered";
})(UserState = exports.UserState || (exports.UserState = {}));
//# sourceMappingURL=FusionAuthClientNative.js.map